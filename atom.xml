<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ninjagg.github.io/Xuan.github.io/</id>
    <title>Gridea</title>
    <updated>2021-06-27T13:17:24.549Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ninjagg.github.io/Xuan.github.io/"/>
    <link rel="self" href="https://ninjagg.github.io/Xuan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ninjagg.github.io/Xuan.github.io/images/avatar.png</logo>
    <icon>https://ninjagg.github.io/Xuan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[PCR_workflow]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/pcr_workflow/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/pcr_workflow/">
        </link>
        <updated>2021-06-18T01:36:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="引物设计">引物设计</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python基础]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/python-ji-chu/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/python-ji-chu/">
        </link>
        <updated>2021-05-25T01:04:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="混合数据类型的列表中-maxmin无法运算">混合数据类型的列表中 max/min无法运算</h1>
<h1 id="调用函数">调用函数</h1>
<h3 id="capitalize-使首字母大写其他字母小写">capitalize 使首字母大写，其他字母小写</h3>
<p>用法：newstr = string.capitalize()<br>
参数：函数括号内什么都不用写<br>
细节：</p>
<pre><code>name = 'xiaoMu'
new_name = name.capitalize()
</code></pre>
<h3 id="lower-将字符串全体小写">.lower() 将字符串全体小写</h3>
<p>用法：newstr = string.casefold()<br>
newstr = string.lower()<br>
参数：括号内什么都不写<br>
细节：只对字符串中字母有效、已经是小写则无效，字符串内可以有数字、符号等内容不会报错，正常对字母部分转换；casefold有将其他语言大写转小写的功能，出的更晚，但平时string.lower()就足够用了</p>
<h3 id="upper-将字符串全体大写">.upper() 将字符串全体大写</h3>
<p>用法：big_str = string.upper()<br>
参数：函数括号内什么都不用写<br>
细节：只对字符串中字母有效、已经大写则无效，字符串内可以有数字、符号等内容不会报错，正常对字母部分转换。</p>
<h3 id="swapcase-将字符串大小写转换">.swapcase() 将字符串大小写转换</h3>
<p>用法： newstr = string.swapcase()<br>
参数：函数括号内什么都不写<br>
细节：字符串内可以有数字、符号等内容不会报错，正常对字母部分转换。</p>
<h3 id="zfill-为字符串定义长度如不满足缺少的部分在字符串前面用0填补">.zfill 为字符串定义长度，如不满足，缺少的部分'在字符串前面'用0填补</h3>
<p>用法：newstr = string.zfill(width)<br>
参数：width: 新字符串希望的宽度<br>
细节：与字符串的字符无关；如果定义长度小于当前字符串长度，则不发生变化</p>
<h3 id="print-打印对象">print() 打印对象</h3>
<p>细节：print('逗号' = '一个空格'; '加号' = '没有空格')</p>
<pre><code>A = 'liu'
B = 'xuan'
print(A, B)  # liu xuan
print(A + b)  #  liuxuan
</code></pre>
<h3 id="count-返回当前字符串中某个成员元素的个数-返回一个数字">count() 返回当前字符串中某个成员(元素)的个数 (返回一个数字)</h3>
<p>用法：inttype = string.count(item)<br>
参数：item: 查询个数的元素<br>
细节：如果查询的成员(元素)不存在，则返回0</p>
<h3 id="isinstance-检查对象是否符合这一类型返回true-false">isinstance() 检查对象是否符合这一类型，返回True, False</h3>
<p>用法：isinstance(a, int)   isinstance(a, (int, float))</p>
<h3 id="tuple-将一个object转换为元组">tuple() 将一个object转换为元组</h3>
<p>用法：tuple(item)<br>
参数：item：需要转换的对象<br>
细节：只能接受一个对象；转换一个字符串时，会将字符串的每个字符拆开，作为元组</p>
<h3 id="insert-将一个对象插入到列表特定位置">insert() 将一个对象插入到列表特定位置</h3>
<p>用法：insert(location, item)<br>
参数：location:数字，指代列表中位置；item：需要添加的字符串向量<br>
细节：计算代价比append要高</p>
<h3 id="pop-将特定位置元素删除与insert正好相反">pop() 将特定位置元素删除，与insert正好相反</h3>
<p>用法：pop(location)<br>
参数：location: 代表需要删除元素的位置<br>
细节：</p>
<h3 id="remove-将列表中的第一个符合要求的值移除">remove() 将列表中的第一个符合要求的值移除</h3>
<p>用法：remove(item)<br>
参数：item：元素的值<br>
细节：惰性匹配?</p>
<h3 id="in-可以检查一个值是否在列表中">in 可以检查一个值是否在列表中</h3>
<p>用法: <code>'dwarf' in b_list</code></p>
<h3 id="not-in-可以检查一个值是否不在列表中">not in 可以检查一个值是否不在列表中</h3>
<p>用法：<code>'dwarf' not in b_list</code></p>
<h3 id="可以使用-连接两个列表或元组">可以使用 + 连接两个列表或元组</h3>
<h3 id="extend-用于对已经定义的列表添加新的元素">extend() 用于对已经定义的列表添加新的元素</h3>
<p>用法：x.extend(item)<br>
参数：item：需要添加的值<br>
细节：使用extend将新元素添加到已经存在的列表中是更好的方式，用'+'连接两个列表代价很高：需要创建新列表并复制对象</p>
<h3 id="sort-对列表进行排序">sort() 对列表进行排序</h3>
<p>用法：a.sort()<br>
参数：括号中可选填<code>key = len</code>，可按照列表中各字符串长度升序排列<br>
细节：升序排列</p>
<h3 id="bisect模块找到元素应当插入的位置插入到相应位置">bisect模块，找到元素应当插入的位置/插入到相应位置</h3>
<p>用法：</p>
<pre><code class="language-import">c = [1, 2, 2, 2, 3, 4, 7]
bisect.bisect(c, 2)  # 查询2在c中应排在哪个位置
bisect.insort(c, 6)  # 将6插入到c中 按升序
</code></pre>
<p>细节：bisect不会检查列表是否排序，对未排序列表使用不会报错，但结果是错误的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cox回归分析]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/cox-hui-gui-fen-xi/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/cox-hui-gui-fen-xi/">
        </link>
        <updated>2021-05-22T11:02:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="单因素cox回归分析">单因素Cox回归分析</h3>
<pre><code>##### load package #####
library(survminer)
library(survival)

##### 单个 单因素Cox回归分析 #####
# rows为样本 cols 为基因 
# 回归
res.cox &lt;- coxph(Surv(OS.time, OS) ~ DPP4, data = TCGA_ferroptosis_surv)  # DPP4是一个基因
summary(res.cox)  # 看结果
ggforest(res.com)  # 作图

##### 实战 批量 单因素Cox回归分析 #####
ferroptosis_gene &lt;- colnames(TCGA_ferroptosis_surv)[1:59]  # 提取ferroptosis相关59个基因
 
 # 此处使用lapply也可 但各子集没有名字了 as.formula提取formula对象，用于回归
univ_formulas &lt;- sapply(ferroptosis_gene,  
                        function(x) {as.formula(paste('Surv(OS.time, OS)~', x))})

univ_models &lt;- lapply( univ_formulas, function(x) {coxph(x, data = TCGA_ferroptosis_surv)})

#提取HR，95%置信区间和p值
univ_results &lt;- lapply(univ_models,
                       function(x){ 
                         x &lt;- summary(x)
                         #获取p值; signif 四舍五入取数
                         p.value &lt;- signif(x$wald[&quot;pvalue&quot;], digits=3)
                         #获取HR
                         HR &lt;-signif(x$coef[2], digits=2);
                         #获取95%置信区间
                         HR.confint.lower &lt;- signif(x$conf.int[,&quot;lower .95&quot;], 2)
                         HR.confint.upper &lt;- signif(x$conf.int[,&quot;upper .95&quot;], 2)
                         HR &lt;- paste0(HR, &quot; (&quot;, 
                                      HR.confint.lower, &quot;-&quot;, HR.confint.upper, &quot;)&quot;)
                         res&lt;-c(p.value,HR)
                         names(res)&lt;-c(&quot;p.value&quot;,&quot;HR (95% CI for HR)&quot;)
                         return(res)  # 返回需要的结果
                       })

# 转换成数据框，并转置
res &lt;- as.data.frame(t(as.data.frame(univ_results, check.names = FALSE)))  # 删除check.names好像也没事

res_fil &lt;- res[res$p.value &lt;= 0.05,]  # 筛选p.value &lt;= 0.05的基因

# 写出结果
# quote = T, character列的内容将会用&quot;&quot;包裹起来。
write.table(file=&quot;univariate_cox_result.txt&quot;, as.data.frame(res), quote = F, sep=&quot;\t&quot;)
write.table(res_fil, file=&quot;p_value_univariate_cox_result.txt&quot;, quote = F, sep=&quot;\t&quot;)

# 批量单因素Cox回归作forest图
#############################################################
#对HR (95% CI for HR)做处理，得到HR和low .95和high .95
#当然也可以改计算univ_results这一步的代码，不要将HR和CI贴起来
############################################################
HR=gsub(&quot;[\\(\\)]&quot;,&quot;&quot;,res$`HR (95% CI for HR)`)
HR=gsub(&quot;-&quot;,&quot; &quot;,HR)
HR=as.data.frame(do.call(cbind,strsplit(HR,&quot; &quot;)),stringsAsFactors=F)
names(HR)=rownames(res)

#################################  
#开始绘图，直接保存到pdf文件中
#################################
pdf(file=&quot;test.pdf&quot;,width=7)
#左边和右边边距稍微留多一点来写变量名称，pvalue和HR
par(mar = c(5,16,4,6))  # mar 设置图片四周距离(bottom, left, top, right) 该区域不是绘图区域

#先用小方块画出HR
plot(as.numeric(HR[1,]),1:dim(HR)[2],
     pch=15, cex=0.8, col=&quot;orange&quot;,bty='n',  # pch 方块形状; cex 方块大小; col 方块颜色; bty 'n'整个plot没有边框
     yaxt='n', ylab=NA, xlab=&quot;Hazard Ratio&quot;,  # yaxt 决定y轴种类 'n'没有y轴; ylab y轴标签; xlab x轴标签
     xlim=c(0,2), # xlim x轴范围，正常应该是range(as.numeric(unlist(HR))) 此处为了美观   
)

#添加中线(无效线)
# lwd 线宽度; lty 线种类 '1'实线 '2'虚线 '3'点线 '4' 点虚线
abline(v=1,col=&quot;grey&quot;,lwd=2,lty=1)  

# xpd = T 不画在绘图区域，可以作为图例使用
for(i in 1:ncol(HR)){
  x=as.numeric(HR[2:3,i])
  #循环画出CI; x为横坐标(2个数) y为纵坐标(2个数) 对应两个点 连成线段
  lines(x,c(i,i),col=&quot;blue&quot;)  
  #添加变量名
  text(-2,i,rownames(res)[i],adj = c(0,0),xpd=T, cex = 0.5) 
  #添加p值
  text(-1.5,i,as.numeric(res[i,1]),adj = c(0,0),xpd=T, cex = 0.5)
  #添加HR和CI
  text(-1,i,as.character(res[i,2]),adj = c(0,0),xpd=T, cex = 0.5)
}

#添加标题
text(-1.5,ncol(HR)+1.5,&quot;pvalue&quot;,xpd=T,adj = c(0,0), cex = 0.8)
text(-1,ncol(HR)+1.5,&quot;HR(CI)&quot;,xpd=T,adj = c(0,0), cex = 0.8)
dev.off()
</code></pre>
<h3 id="多因素cox回归分析">多因素Cox回归分析</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[R tips]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/r-tips/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/r-tips/">
        </link>
        <updated>2021-05-13T08:32:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="合并多个同类型文件如多个excel文件根据药物components预测的靶点信息">合并多个同类型文件，如多个excel文件(根据药物components预测的靶点信息)</h1>
<pre><code>path &lt;- list.files(path = &quot;../hongshen_alcohol/components_target_csv/&quot;, pattern = &quot;*.csv&quot;, full.names = T) #将各个文件的路径+文件名作为单个因子保存在列表path中
predicted_target &lt;- map_df(path1, ~read.csv(., header = T)) %&gt;% filter(Probability. &gt; 0) # map_df 返回一个data.frame，将一个函数/匿名函数应用到list的每一个Vector，默认按行合并约等于“map_dfr”
</code></pre>
<h1 id="对两个数据集取交集">对两个数据集取交集</h1>
<p><code>intersect(allergic$gene, predicted_target$Common.name)</code><br>
<em>intersect</em> 默认对两个数据框中具有同一列名的数据取交集并返回一个数据框，若无同一列名可设定某一列具体数值返回vector</p>
<h1 id="拆分object">拆分object</h1>
<p><code>strsplit(gene_entrez_list[1], split = &quot;/&quot;)</code><br>
使用<em>strsplit</em>函数<br>
<strong>Description</strong><br>
Split the elements of a character vector x into substrings according to the matches to substring split within them.</p>
<h1 id="转化基因名">转化基因名</h1>
<p>从TCGA下载癌症基因表达矩阵文件，对ENSG0100213.. 格式基因名转换&quot;SYMBOL&quot;格式<br>
<em>select</em> 返回一个矩阵(保留一对多情况，长度与原行数不符)<br>
<em>mapIds</em> 返回一个列表，长度与原行数相符(推荐使用)</p>
<pre><code>options(connectionObserver = NULL)  # 目前org.Hs.eg.db有小Bug 需要两个一起使用
libraray(org.Hs.eg.db)

keytypes(org.Hs.eg.db)  # 查看有哪些命名格式
head(keys(org.Hs.eg.db, keytype = &quot;ENSEMBL&quot;))  # 查看各个命名格式是什么样子

gene &lt;- as.character(TCGA_count_data$Ensembl_ID)  # 需要整理成character格式基因名
length(gene)  # 查看长度

temp &lt;- str_replace_all(gene, pattern = &quot;\\.\\d*$&quot;, replacement = &quot;&quot;)  # ENSEMBL ID略有特殊，后面有类似&quot;.05&quot;的后缀，是版本号，需要使用正则清除

tran_temp &lt;- mapIds(x = org.Hs.eg.db,
       keys = temp,  # 需要转换的gene set
       column = &quot;SYMBOL&quot;,  # column 代表gene set需要转换后命名格式
       keytype = &quot;ENSEMBL&quot;)  # keytype 代表gene set转换前的命名格式
length(tran_temp)  # 再次查看长度，防止出现1对多情况
</code></pre>
<h1 id="对r-object行名赋值报错">对R object行名赋值报错</h1>
<p>Error in .rowNamesDF&lt;- (x, value = value) : 'row.names'里不允许有遗漏值<br>
原因可能在于<strong>行名中存在NA</strong></p>
<h1 id="对r-数据框取子集-行名消失">对R 数据框取子集 行名消失</h1>
<p>使用<em>as.data.frame</em>对object转换，再取子集就可以保留行名</p>
<h1 id="lapply-对列表每一个元素施加function">lapply 对列表每一个元素施加Function</h1>
<p>返回一个与输入等长的list<br>
lapply(X, FUN, ...)</p>
<p>衍生有sapply<br>
sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)</p>
<p><code>univ_models &lt;- lapply( univ_formulas, function(x) {coxph(x, data = TCGA_ferroptosis_surv)})</code></p>
<h1 id="signif-获取四舍五入后的值">signif 获取四舍五入后的值</h1>
<p>signif(x, digits = 6) 获取6位小数的四舍五入值</p>
<h1 id="t-转置行列后数据框将不再是dataframe格式">t() 转置行列后，数据框将不再是data.frame格式</h1>
<h1 id="paste-默认以空格作为分隔paste0-默认无内容作为分隔">paste 默认以空格作为分隔，paste0 默认无内容作为分隔</h1>
<h1 id="writetable-用于保存带行名的数据框">write.table() 用于保存带行名的数据框</h1>
<p>write.table(x, file = &quot;./&quot;, quote = F)  #quote = F 内容不加双引号</p>
<h1 id="ifelse-结合for循环对数据框进行判定-赋值">ifelse() 结合for循环对数据框进行判定、赋值</h1>
<p>ifelse(test, yes, no)</p>
<pre><code>for (i in c(1:59)) {
  TCGA_ferroptosis_surv[[i]] &lt;- ifelse(TCGA_ferroptosis_surv[[i]]&gt;median(TCGA_ferroptosis_surv[[i]]),'high','low')
}
dim(TCGA_ferroptosis_surv)  # 567 rows &amp; 64 cols
</code></pre>
<h1 id="table-查看数据表df的samp_id列含有哪些元素及重复了多少次">table() 查看数据表df的samp_id列含有哪些元素及重复了多少次</h1>
<p><code>table(df$sample_id)</code></p>
<h1 id="example-查看某一函数示例">example() 查看某一函数示例</h1>
<p><code>example(exp)</code></p>
<h1 id="str_sub-按字符串起始-终止位点提取字符">str_sub() 按字符串起始、终止位点提取字符</h1>
<p>用法：</p>
<pre><code>library(stringr)
str_sub(Filename, 23, 32)  # 提取Filename的第23-32字符
</code></pre>
<h1 id="str_split-按pattern将字符串-元素分隔">str_split() 按&quot;pattern&quot;将字符串、元素分隔</h1>
<p>用法：</p>
<pre><code>library(stringr)
str_split(Filename, pattern = &quot;\t&quot;, simplify = T)
</code></pre>
<p>细节：缺省值simplify = F, 返回一个列表；simplify = T， 返回一个向量</p>
<h1 id="identical-判断两个对象是否完全相等">identical() 判断两个对象是否完全相等</h1>
<p>用法：<code>identical(x, y)</code></p>
<h1 id="cmd-opt-o-快速折叠r脚本中所有分组shift-cmd-opt-o-快速打开r脚本中所有分组">cmd + opt + o 快速折叠R脚本中所有分组，shift + cmd + opt + o 快速打开R脚本中所有分组</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中药+疾病+网络药理学]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/ji-bing-ba-dian-shai-xuan-guo-lu/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/ji-bing-ba-dian-shai-xuan-guo-lu/">
        </link>
        <updated>2021-05-12T11:57:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="热门疾病">热门疾病</h1>
<p>如肿瘤、心血管等热门疾病在相关疾病数据库 <a href="https://www.genecards.org/">genecard</a> <a href="https://omim.org/">OMIM</a>搜索英文关键字，挑选一个term即可</p>
<h1 id="冷门疾病">冷门疾病</h1>
<p>如过敏(allergic)、光老化(photoaging)等冷门疾病可以在<a href="https://omim.org/">OMIM</a>搜索英文关键字，此时平均一个term仅有个位数的gene target无法网络药理学或其他筛选的要求(300-400个)<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620821026638.png" alt="" loading="lazy"><br>
可选择将结果展示为Gene Map Table<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620821093188.png" alt="" loading="lazy"><br>
下载excel格式文件<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620821139114.png" alt="" loading="lazy"><br>
并在excel中利用&quot;分列&quot;功能将gene target整理为一列新的数据，另存为一个文件，后续在R中进行清洗</p>
<h3 id="r-part-1">R Part 1</h3>
<pre><code>df &lt;- read_excel(path = &quot;../allergic_gene.xlsx&quot;)
df_rm_dup &lt;- unique(df) #去重
allergic_gene &lt;- na.omit(df_rm_dup) #去除na

sum(is.na(df_rm_dup)) #查看是否有na存在
sum(is.na(allergic_gene)) #查看是否有na存在

write_csv(allergic_gene, file = &quot;../allergic_fil_gene.csv&quot;) #写出整洁的疾病靶点
</code></pre>
<h1 id="tcmsptcmid-数据库检索中药单体成分">TCMSP/TCMID 数据库检索中药单体成分</h1>
<p><a href="https://old.tcmsp-e.com/tcmsp.php">TCMSP</a><br>
<a href="http://119.3.41.228:8000/tcmid/">TCMID</a><br>
通过上述2个数据库直接获得SMILE格式<br>
或获取CAS号，通过<a href="https://pubchem.ncbi.nlm.nih.gov/">pubchem</a>获取相应SMILE格式<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620904441007.png" alt="" loading="lazy"><br>
<strong>通过数据库收集中药单体成分信息时极有可能获得重复值，注意筛查</strong></p>
<h1 id="预测靶点相关成分">预测靶点相关成分</h1>
<p><a href="http://www.swisstargetprediction.ch/">Swiss</a><br>
将SMILE格式文件作为Input提交<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620904478125.png" alt="" loading="lazy"><br>
下载csv格式靶点信息(默认下载前100个)至一个文件夹<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620904611812.png" alt="" loading="lazy"><br>
在每一个单体药物预测靶点的excel文件内加入&quot;drug&quot;列，将单体名字输入并统一格式<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620979402621.png" alt="" loading="lazy"></p>
<h3 id="r-part-2">R Part 2</h3>
<pre><code>path1 &lt;- list.files(path = &quot;../hongshen_alcohol/components_target_csv/&quot;, pattern = &quot;*.csv&quot;, full.names = T) #合并所有单体预测靶点的路径至path1
predicted_target &lt;- map_df(path1, ~read.csv(., header = T)) %&gt;% 
  filter(Probability. &gt; 0) #提取所有单体预测靶点信息，按行合并至predicted_target
write_csv(predicted_target, file = &quot;./hongshen_alcohol/bind_predicted_targets.csv&quot;) #写出整合后的&quot;预测靶点文件&quot;
uni_drug &lt;- as.data.frame(unique(predicted_target$drug)) #提取所有单体药物信息
write_csv(uni_drug, file = &quot;./hongshen_alcohol/unique_drug.csv&quot;) #写出所有单体药物信息
</code></pre>
<h1 id="将疾病靶点与中药成分预测靶点做交集保留交集靶点">将&quot;疾病靶点&quot;与&quot;中药成分预测靶点&quot;做交集，保留交集靶点</h1>
<h3 id="r-part-3">R Part 3</h3>
<pre><code>allergic &lt;- read_csv(file = &quot;./allergic_fil_gene.csv&quot;)
predicted_target &lt;- read_csv(file = &quot;./hongshen_alcohol/bind_predicted_targets.csv&quot;) %&gt;% select(Common.name) %&gt;% unique(.)

colnames(predicted_target) &lt;- &quot;gene&quot; #将两个数据集的列名设为一致

both &lt;- intersect(allergic, predicted_target) #有一致列名时，intersect返回数据框
write_csv(both, file = &quot;./hongshen_alcohol/intersection.csv&quot;) #写出数据
</code></pre>
<p>构建&quot;疾病&quot;-&quot;disease &amp; drug 交集靶点&quot;-&quot;中药&quot;network，若交集靶点过少可仅采用&quot;中药-成分-预测靶点&quot;构建Network</p>
<h1 id="cytoscape作图">Cytoscape作图</h1>
<p>制作network、type文件<br>
<em>network</em>文件形式</p>
<pre><code>ID      Symbol
drug1   STAT3
drug1   PTAFR
drug1   IL2
drug2  MAPK
...
drug15  CDK1
HS      drug1 #HS 红参(中药)
HS      drug2
...
HS      drug15
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620979877334.png" alt="" loading="lazy"></figure>
<p><em>type</em>文件格式</p>
<pre><code>Term    Type
drug1   drug
drug2   drug
...
drug15  drug
STAT3   gene
PTAFR   gene
IL2    gene
MAPK    gene
Allergic    A #Allergic (疾病)
HS          B #HS 红参(中药)
</code></pre>
<p><img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620980699539.png" alt="" loading="lazy"><br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620980729126.png" alt="" loading="lazy"></p>
<p>Cytoscape导入制作好的Network、Type文件<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620981090810.png" alt="" loading="lazy"><br>
将Symbol属性设置为&quot;target node&quot;<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620981157761.png" alt="" loading="lazy"><br>
菜单栏&quot;Tools&quot;、&quot;Analyze Network&quot;(不勾选对号为无定向网络分析，本次不勾)<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1620981710779.png" alt="" loading="lazy"></p>
<h1 id="go-kegg富集">GO、KEGG富集</h1>
<p>R Part 3</p>
<pre><code>### GO富集
erich.go.all &lt;- enrichGO(gene = DEG.gene_symbol_entrez_id, 
                         OrgDb = org.Hs.eg.db, 
                         keyType = &quot;ENTREZID&quot;, ont = &quot;ALL&quot;,
                         pvalueCutoff = 0.01, qvalueCutoff = 0.05,
                         readable = T, # 使用gene ID表示gene FALSE的话就返回entrez ID
                         pool = T) # ont = &quot;ALL&quot;时 pool = T返回一个整合的dataframe
temp &lt;- data.frame(erich.go.all)
# barplot 一步GO三大类出图
dotplot(erich.go.all, split=&quot;ONTOLOGY&quot;)+facet_grid(ONTOLOGY~., scale=&quot;free&quot;) 

pdf(file = &quot;./paper_dotplot_BP_CC_MF&quot;, width = 9, height = 9) #最后保存 pdf 9 * 9
png(filename = &quot;./hongshen_alcohol/test.png&quot;, width = 800, height = 800)
dev.off() #pdf png 和dev.off一起使用

### KEGG
erich.kegg.all &lt;- enrichKEGG(gene = DEG.gene_symbol_entrez_id, 
                             organism = &quot;hsa&quot;, 
                             keyType = &quot;kegg&quot;,
                             pvalueCutoff = 0.01, qvalueCutoff = 0.05)
temp &lt;- data.frame(erich.kegg.all)
# Chord图
temp_kegg &lt;- data.frame(erich.kegg.all)[1:10,] %&gt;%
  mutate(Category=&quot;KEGG&quot;) #取top10 富集到的kegg通路
temp_kegg &lt;- temp_kegg[,c(10,1,2,8,6)] #筛选需要的列
terms &lt;- data.frame(Category=temp_kegg$Category, # Chord要求的&quot;terms&quot;文件，“列名”不可变
                    ID=temp_kegg$ID, 
                    Term=temp_kegg$Description, 
                    Genes = temp_kegg$geneID, 
                    adj_pval=temp_kegg$p.adjust) 
genes &lt;- data.frame(ID=enrich_raw_data$gene_symbol, # Chord要求的&quot;genes&quot;文件,列名不可变
                    logFC=rnorm(length(enrich_raw_data$gene_symbol), #本次分析没有logFC，生成随机数列代替
                    mean = 0, sd = 2))

# entrez_id to gene_symbol 
# 与GO结果不同，Kegg结果中的Genes是entrezid，需要转换为gene_symbol再作图
gene_entrez_list &lt;- temp_kegg$geneID 

# 将gene_entrez_list以&quot;/&quot;的结果拆分成outcome&quot;list&quot;中的各个向量
outcome &lt;- vector()
for (i in seq_along(gene_entrez_list)) {
  outcome[i] &lt;- strsplit(gene_entrez_list[i], split = &quot;/&quot;)
}

#将outcome中的各个向量的值从entrezid转换为gene_symbol columens是要转换的格式，keytype是当前格式
gene_symbol &lt;- list()
for (i in seq_along(outcome)) {
  gene_symbol[[i]] &lt;- select(org.Hs.eg.db, 
                             keys=outcome[[i]], #keys 为需要转换格式的set
                             columns=&quot;SYMBOL&quot;, #columns 为需要转换格式的set 当前命名格式
                             keytype = &quot;ENTREZID&quot;) #keytype 需要转换成的命名格式
}

#将gene_sybol中各组对应的gene_symbol整合成以&quot;,&quot;分隔的一个向量，赋值给terms$Genes
for (i in seq_along(terms$Genes)) {
  terms$Genes[i] &lt;- str_c(gene_symbol[[i]]$SYMBOL, collapse = &quot;,&quot;)
}

# 画图
circ &lt;- circle_dat(terms = terms, genes = genes)
chord &lt;- chord_dat(data = circ, genes = genes, process = terms$Term)
GOChord(chord,
        space = 0.05, # space 各弦部分间的距离
        gene.order = 'logFC', # 以logFC进行排序
        gene.space = 0.18, # gene.space gene标签与弦之间的距离
        process.label = 7,
        gene.size = 2) # gene.size gene标签字体大小
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Conda Collecting package metadata (current_repodata.json): failed 解决方法]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/conda-collecting-package-metadata-current_repodatajson-failed-jie-jue-fang-fa/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/conda-collecting-package-metadata-current_repodatajson-failed-jie-jue-fang-fa/">
        </link>
        <updated>2021-04-16T11:37:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题背景">问题背景</h1>
<p>conda重置，设置清华源、中科大源都无法解决<code>conda install mamba</code>时的Collecting package metadata (current_repodata.json): failed</p>
<h1 id="解决方法">解决方法</h1>
<p>考虑可能是默认源问题，删除~/.condarc文件最下面的defaults后可以正常使用。但还有可能报错（并不是每次都有）failed with initial frozen solve. Retrying with flexible solve.该错误不影响执行。</p>
<p>也可以通过以下设置解决（本次没设置）：<code>conda config --set channel_priority flexible</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mac本地安装cufflinks 2.1.1 tar.gz文件]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/mac-ben-di-an-zhuang-cufflinks-211-targz-wen-jian-conda-mei-you/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/mac-ben-di-an-zhuang-cufflinks-211-targz-wen-jian-conda-mei-you/">
        </link>
        <updated>2021-04-12T12:03:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题背景">① 问题背景</h1>
<h3 id="cuffdiff-221版本python27-对hisat2的mapping后bam文件数据处理时报错segmentation-fault-11-据说是火星撞地球级别的错误报告尝试几乎所有方法和参数无法起效">cuffdiff 2.2.1版本(python=2.7) 对hisat2的mapping后bam文件数据处理时报错：Segmentation fault: 11 据说是&quot;火星撞地球&quot;级别的错误报告，尝试几乎所有方法和参数无法起效</h3>
<p><img src="https://ninjagg.github.io/Xuan.github.io//post-images/1618229859018.png" alt="error" loading="lazy"><br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1618229884767.png" alt="error code" loading="lazy"></p>
<h1 id="2-解决方法">② 解决方法</h1>
<h3 id="安装cufflinks-211版本即解决该问题python379但conda上并没有cufflinks-211版本因此在cufflinks官网下载该软件cufflinks-211osx_x86_64targz">安装cufflinks 2.1.1版本即解决该问题(python=3.7.9)，但conda上并没有cufflinks 2.1.1版本，因此在<a href="http://cole-trapnell-lab.github.io/cufflinks/releases/v2.1.1/">cufflinks官网</a>下载该软件&quot;cufflinks-2.1.1.OSX_x86_64.tar.gz&quot;</h3>
<pre><code>cd ~/test_HD/biosofts
tar -zxvf cufflinks-2.1.1.OSX_x86_64.tar.gz
cd cufflinks-2.1.1.OSX_x86_64
vim ~/.bash_profile
</code></pre>
<h3 id="在行末添加一行">在行末添加一行</h3>
<pre><code>export PATH=//Users/mac/test_HD/biosofts/cufflinks-2.1.1.OSX_x86_64:$PATH
source ~/.bash_profile #重启bash文件 环境变量即生效
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[t-test检验 & Venn作图]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/t-test-jian-yan/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/t-test-jian-yan/">
        </link>
        <updated>2021-03-19T10:48:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一实验分组-con-uvb-treatment">一：实验分组 CON UVB TREATMENT</h1>
<p>质谱检测各组蛋白表达量，可采用ANOVA或t-test两两检验<br>
本次采用t-test检验 CON vs. UVB &amp; UVB vs. TREATMENT 后取显著性差异结果交集，进一步根据Fold Change情况阐述相应生物学意义</p>
<h1 id="二r代码">二：R代码</h1>
<pre><code>####load package####
library(tidyverse)
library(readxl)
library(VennDiagram)
library(writexl)

####读取数据并清洗####
rm(list = ls())
raw_data &lt;- read_excel(path = &quot;01_2020-125-C-01 original data 原始数据.xlsx&quot;)
df &lt;- as.data.frame(t(raw_data)) #t()转置后是matrix需要as.data.frame转为数据框
colnames(df) &lt;- as.character(df[1, ]) #更换列名
df_clean &lt;- df[-1, ] #删掉第一行(原列名)

####t-test####
1:3列是Con组数据 4:6是UVB组数据 7:9是Treatment 

##############CON vs UVB
##检测方差是否齐 基本都齐
##自己造轮子进行批量方差齐性检验 ①创建一个列表 ②定义 i 是&quot;行数&quot; ③对con(1:3) vs. uvb(4:6) &amp; uvb(4:6) vs. treatment(7:9)进行检测 

con_u_var &lt;- list() #创建一个列表
for (i in c(1:length(rownames(df_clean)))) {
    result &lt;- var.test(as.numeric(df_clean[i, 1:3]), as.numeric(df_clean[i, 4:6]))
    con_u_var[[i]] &lt;- result[[3]]
} #定义i是&quot;行数&quot;，var.test()返回一个列表其中[[3]]是方差检验的数值(大于0.05方差齐)，将每一行(每一个观测/蛋白)的方差检验结果赋值给变量&quot;result&quot;，将结果中的方差检验数值赋值给con_u_var，顺序与行名对应

##t-test
con_u_t_test &lt;- list()
for (i in c(1:length(rownames(df_clean)))) {
    result &lt;- t.test(as.numeric(df_clean[i, 1:3]), as.numeric(df_clean[i, 4:6]), var.equal = T)
    con_u_t_test[[i]] &lt;- result[[3]]
}

##############UVB vs Treatment
##检查方差
uvb_a_mg_var &lt;- list()
for (i in c(1:length(rownames(df_clean)))) {
  result &lt;- var.test(as.numeric(df_clean[i, 4:6]), as.numeric(df_clean[i, 7:9]))
  uvb_a_mg_var[[i]] &lt;- result[[3]]
}

##t-test
uvb_a_mg_t_test &lt;- list()
for (i in c(1:length(rownames(df_clean)))) {
  result &lt;- t.test(as.numeric(df_clean[i, 4:6]), as.numeric(df_clean[i, 7:9]), var.equal = T)
  uvb_a_mg_t_test[[i]] &lt;- result[[3]]
}

####计算均值 检测fold change####
##CON组
temp_mean_con &lt;- vector()
for (i in c(1:length(rownames(df_clean)))) {
  test &lt;- mean(as.numeric(df_clean[i, 1:3]))
  temp_mean_con[i] &lt;- test
}

##UVB组
temp_mean_UVB &lt;- vector()
for (i in c(1:length(rownames(df_clean)))) {
  test2 &lt;- mean(as.numeric(df_clean[i, 4:6]))
  temp_mean_UVB[i] &lt;- test2
}

##Treatment组
temp_mean_a_mg &lt;- vector()
for (i in c(1:length(rownames(df_clean)))) {
  test3 &lt;- mean(as.numeric(df_clean[i, 7:9]))
  temp_mean_a_mg[i] &lt;- test3
}

####整理结果，写出文件####
df_end &lt;- df_clean %&gt;%
  mutate(P_con_vs_u = signif(as.numeric(con_u_t_test)), 
         P_uvb_vs_a_mg = signif(as.numeric(uvb_a_mg_t_test)),
         FC_con_U = temp_mean_UVB / temp_mean_con,
         FC_UVB_a_mg = temp_mean_a_mg / temp_mean_UVB)
rownames(df_end) &lt;- rownames(df_clean)
write.csv(df_end, file = &quot;./outcome_all_data.csv&quot;, row.names = T)
write.tabel(df_end, file = &quot;./outcome_all_data_test&quot;) #写出\t分隔的txt文件，再次读入时不会存在行名变化问题csv会存在部分问题不知是不是bug

####筛选结果####
all_temp &lt;- df_end %&gt;%   #筛选CON vs. UVB &amp; UVB vs. Treatment组中均显著的蛋白
  filter(P_con_vs_u &lt; 0.05 &amp; P_uvb_vs_a_mg &lt; 0.05)
write.csv(all_temp, file = &quot;./outcome_intersection.csv&quot;) ###写出数据

con_u_temp &lt;- df_end %&gt;% #筛选CON vs. UVB 单显著 cutoff == 0.05 
  filter(P_con_vs_u &lt; 0.05)
write.csv(all_temp, file = &quot;./outcome_con_vs_uvb.csv&quot;) ###写出数据

u_a_mg_temp &lt;- df_end %&gt;% #筛选UVB vs. Treatmen cutoff == 0.05 
  filter(P_uvb_vs_a_mg &lt; 0.05)
write.csv(all_temp, file = &quot;./outcome_uvb_vs_a_mg.csv&quot;) ###写出数据

####Venn图绘制####
all_name &lt;- as.character(rownames(all_temp))
con_u_name &lt;- as.character(rownames(con_u_temp))
uvb_a_mg_name &lt;- as.character(rownames(u_a_mg_temp))
venn.plot &lt;- venn.diagram(list(&quot;A&quot; = con_u_name, &quot;B&quot; = uvb_a_mg_name),
             filename = &quot;venn.tiff&quot;, 
             fill=c(&quot;red&quot;,&quot;blue&quot;),
             lty = 1, #圆轮廓线种类：实线、点虚线……
             lwd = 1, #圆轮廓线宽度
             col = &quot;black&quot;,
             cat.col = &quot;black&quot;,
             alpha=c(0.6,0.6),
             cat.cex = 1.5, #圆的分组名大小
             cat.fontface = &quot;bold&quot;,
             margin = 0.07,
             ext.text = F, ####区域过小时不允许外界标签，就没有黑色直线了
             cex = 1.5 ) ##圆内数字大小


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于TCGA的单基因survival analysis]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/ji-yu-tcga-de-dan-ji-yin-survival-analysis/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/ji-yu-tcga-de-dan-ji-yin-survival-analysis/">
        </link>
        <updated>2021-03-18T12:17:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一确定基因名字">一：确定基因名字</h1>
<p>基因的名字很多，登录<a href="https://ninjagg.github.io/Xuan.github.io//post-images/1616070388162.png">Uniprot</a></p>
<h1 id="二疾病">二：疾病</h1>
<p>以结直肠癌为例</p>
<h1 id="三tcga基因表达以及临床生存信息下载">三：TCGA&quot;基因表达&quot;以及&quot;临床生存信息&quot;下载：</h1>
<p><a href="https://xenabrowser.net/datapages/">UCSC Xena</a><br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1616071647107.png" alt="" loading="lazy"><br>
&quot;基因表达&quot;数据下载：<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1616071773525.png" alt="" loading="lazy"><br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1616071809308.png" alt="" loading="lazy"><br>
&quot;临床生存信息&quot;下载：<br>
<img src="https://ninjagg.github.io/Xuan.github.io//post-images/1616071883082.png" alt="" loading="lazy"><br>
下载后放到R的工作目录中即可</p>
<h1 id="四r代码survival-analysis">四：R代码survival analysis</h1>
<pre><code>rm(list = ls())

####load package####
library(tidyverse)

####读取数据####
gene_exp &lt;- read.table(file = &quot;./TCGA.COAD.sampleMap%2FHiSeqV2&quot;, header = T, sep = &quot;\t&quot;)

####gene_expression数据清洗####
rownames(gene_exp) &lt;- gene_exp[ ,1] #第一列是Sample，将第一列作为行名
gene_exp &lt;- gene_exp[ ,-1] #删掉原本第一列Sample的数据

####得到基因KIAA1324在各个样本中的表达数据####
GENE &lt;- as.data.frame(t(gene_exp)) #t()转置之后是matrix 需要转换
temp &lt;- rownames(GENE) == &quot;KIAA1324&quot; #筛选，基因的名字(Gene names)都试一试
GENE2 &lt;- GENE[temp, ]
GENE &lt;- GENE2 #防止变量弄混
GENE &lt;- as.data.frame(t(GENE)) #让&quot;临床分组&quot;变为观测，&quot;基因名&quot;为变量

####计算基因&quot;KIAA1324&quot;表达量中位数####
med &lt;- median(GENE$KIAA1324)

####筛选基因高低表达####
high &lt;- GENE$KIAA1324 &gt; med
low &lt;- GENE$KIAA1324 &lt;= med
GENE[high, ] &lt;- &quot;High&quot;
GENE[low, ] &lt;- &quot;Low&quot;

####获取临床####
clinical &lt;- read.table(file = &quot;./survival%2FCOAD_survival.txt&quot;, header = T, sep = &quot;\t&quot;)

####clinical数据清洗####
clinical_clean &lt;- data.frame(gsub(&quot;-&quot;, &quot;.&quot;, clinical$Sample), clinical) #将行名中连接的&quot;-&quot;换为&quot;.&quot;
colnames(clinical_clean[1]) &lt;- &quot;SampleID&quot; #修改列&quot;名字&quot;
clinical_clean_2 &lt;- clinical_clean[ ,-2] #删除原列&quot;名字&quot;

####合并基因表达及临床数据####
gene_clinical &lt;- data.frame(clinical_clean_2[match(rownames(GENE), clinical_clean_2$SampleID), ], GENE)

####&quot;KIAA1324&quot;低表达为1，高表达为2####
gene_clinical$KIAA1324 &lt;- ifelse((gene_clinical$KIAA1324 == &quot;Low&quot;), 1, 2)
GC &lt;- gene_clinical

##################生存分析作图 OS作图####
library(survival)
fit.surv &lt;- Surv(GC$OS.time, GC$OS)
km &lt;- survfit(fit.surv~1, data = GC)
km_2 &lt;- survfit(fit.surv~KIAA1324, data = GC)

library(survminer)
ggsurvplot(km_2,
legend.title = &quot;KIAA1324&quot;, #改变图例名称
legend.labs = c(&quot;High&quot;, Low&quot;),
pval = T #显示P值
)

##################生存分析作图 OS作图####
library(survival)
fit.surv &lt;- Surv(GC$PFI.time, GC$PFI)
km &lt;- survfit(fit.surv~1, data = GC)
km_2 &lt;- survfit(fit.surv~KIAA1324, data = GC)

library(survminer)
ggsurvplot(km_2,
legend.title = &quot;KIAA1324&quot;, #改变图例名称
legend.labs = c(&quot;High&quot;, &quot;Low&quot;),
pval = T #显示P值
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac上安装Aspera步骤]]></title>
        <id>https://ninjagg.github.io/Xuan.github.io/post/mac-shang-an-zhuang-aspera-bu-zou/</id>
        <link href="https://ninjagg.github.io/Xuan.github.io/post/mac-shang-an-zhuang-aspera-bu-zou/">
        </link>
        <updated>2021-03-15T07:28:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-下载aspera">1. 下载Aspera</h1>
<h2 id="谷歌浏览器也可安装图形界面本次安装使用命令行界面">谷歌浏览器也可安装图形界面（本次安装使用命令行界面）</h2>
<pre><code>cd /Users/mac/test_HD/biosofts
wget https://d3gcli72yxqn2z.cloudfront.net/connect_latest/v4/bin/IBMAsperaConnectInstallerOneClick-3.11.1.58.dmg
</code></pre>
<h1 id="2-安装aspera">2. 安装Aspera</h1>
<h2 id="图形界面中">图形界面中</h2>
<p>直接在/Users/mac/test_HD/biosofts中双击XXX.dmg文件，后拖到Application即可</p>
<h2 id="命令行界面中">命令行界面中</h2>
<h4 id="如果是dmg文件"><em>如果是.dmg文件</em></h4>
<p>.dmg文件会安装到/Volumes下</p>
<pre><code>cd /Users/mac/test_HD/biosofts
hdiutil attach xxx.dmg
cp -rf ./xxx.app /Applications
</code></pre>
<h4 id="如果是pkg文件"><em>如果是.pkg文件</em></h4>
<pre><code>cd /Users/mac/test_HD/biosofts
sudo installer -pkg xxx.pkg -target /Application
</code></pre>
<h4 id="如果是configsh文件"><em>如果是.config/.sh文件</em></h4>
<p>则运行对应文件</p>
<h1 id="2-将aspera-connect添加到环境变量中">2. 将Aspera Connect添加到环境变量中</h1>
<p>Aspera Connect安装完</p>
<pre><code>cd ~
vim .bash_profile
</code></pre>
<p>添加环境变量<br>
<code>PATH=/Users/mac/Applications/Aspera_Connect.app/Contents/Resources:$PATH</code><br>
保存退出，重新打开terminal</p>
<h1 id="3-关闭mac防火墙本机已关闭">3. 关闭Mac防火墙（本机已关闭）</h1>
<h1 id="4-aspera万能使用语句">4. Aspera万能使用语句</h1>
]]></content>
    </entry>
</feed>